<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Integrations</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="integrations">Integrations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although YAVI doesn&#8217;t depend on anything, it has interfaces that magically fit into Framework.</p>
</div>
<div class="sect2">
<h3 id="_integration_with_bindingresult_in_spring_mvc">Integration with <code>BindingResult</code> in Spring MVC</h3>
<div class="paragraph">
<p><code>ConstraintViolations#apply</code> accepts the Function Interface with the same arguments as Spring Framework&#8217;s <code>BindingResult#rejectValue</code> method and passes the violation messages.</p>
</div>
<div class="paragraph">
<p>To reflect validation results by YAVI in a Controller of Spring MVC, you can write the following code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final Validator&lt;UserForm&gt; validator = ...;

@PostMapping(path = "users")
public String createUser(Model model, UserForm userForm, BindingResult bindingResult) {
    ConstraintViolations violations = validator.validate(userForm);
    if (!violations.isValid()) {
        violations.apply(BindingResult::rejectValue);
        return "userForm";
    }
    // ...
    return "redirect:/";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you like the functional way, you can also write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final Validator&lt;UserForm&gt; validator = ...;

@PostMapping(path = "users")
public String createUser(Model model, UserForm userForm, BindingResult bindingResult) {
    return validator.applicative()
        .validate(userForm)
        .fold(violations -&gt; {
            ConstraintViolations.of(violations).apply(BindingResult::rejectValue);
            return "userForm";
        }, form -&gt; {
            // ...
            return "redirect:/";
        });
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>List&lt;ContraintViolation&gt;</code> is passed to the function of the first argument of <code>Validated#fold</code> instead of <code>ConstraintViolations</code>. You can convert the <code>List&lt;ContraintViolation&gt;</code> to <code>ConstraintViolations</code> by using the <code>ConstraintViolations#of</code> method.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_converting_constraintviolations_to_the_format_to_serialize_as_a_response_body">Converting <code>ConstraintViolations</code> to the format to serialize as a response body</h3>
<div class="paragraph">
<p><code>ConstraintViolation</code> is not suitable for serializing with a serializer like Jackson. Instead, you can use <code>ConstraintViolation#detail</code> method to convert it to a <code>ViolationDetail</code> object that is easy to serialize.</p>
</div>
<div class="paragraph">
<p>The <code>ConstraintViolations#details</code> method translates all <code>ConstraintViolation</code> s and returns <code>List&lt;ViolationDetail&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final Validator&lt;UserCreateRequest&gt; validator = ...;

@PostMapping(path = "users")
public ResponseEntity&lt;?&gt; createUser(@RequestBody UserCreateRequest request) {
    ConstraintViolations violations = validator.validate(request);
    if (violations.isValid()) {
        User created = userService.create(request.toUser());
        return ResponseEntity.ok(created);
    } else {
        return ResponseEntity.badRequest().body(violations.details());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you like the functional way, you can also write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final Validator&lt;UserCreateRequest&gt; validator = ...;

@PostMapping(path = "users")
public ResponseEntity&lt;?&gt; createUser(@RequestBody UserCreateRequest request) {
    return validator.applicative()
        .validate(request)
        .map(req -&gt; userService.create(req.toUser()))
        .mapErrors(violations -&gt; ConstraintViolations.of(violations).details())
        // or .mapErrorsF(ConstraintViolation::detail)
        .fold(details -&gt; ResponseEntity.badRequest().body(Map.of("message", "Invalid request body", "details", details)),
            created -&gt; ResponseEntity.ok(created));
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>ViolationDetail</code> works with GraalVM native image out of the box.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_integration_with_spring_webflux_fn">Integration with Spring WebFlux.fn</h3>
<div class="paragraph">
<p>YAVI will be a great fit for <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-fn">Spring WebFlux.fn</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">final Validator&lt;UserCreateRequest&gt; validator = ...;

public RouterFunction&lt;ServerResponse&gt; routes() {
    return route()
        .POST("/users", request -&gt; request.bodyToMono(UserCreateRequest.class)
            .flatMap(body -&gt; validator.applicative()
                .validate(body)
                .map(req -&gt; userService.create(req.toUser()))
                .mapErrors(violations -&gt; ConstraintViolations.of(violations).details())
                // or .mapErrorsF(ConstraintViolation::detail)
                .fold(details -&gt; ServerResponse.badRequest().bodyValue(Map.of("message", "Invalid request body", "details", details)),
                    created -&gt; ServerResponse.ok().bodyValue(created))))
        .build();
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
YAVI was originally developed as a validator naturally fit with Spring WebFlux.fn.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-06-15 15:06:05 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</body>
</html>