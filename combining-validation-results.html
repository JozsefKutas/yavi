<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Combining validation results</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="combining-validation-results">Combining validation results</h2>
<div class="sectionbody">
<div class="paragraph">
<p>YAVI supports a functional programming concept known as <a href="https://en.wikipedia.org/wiki/Applicative_functor">Applicative Functor</a>.
A sequence of validations are executed while accumulating the results (<code>ConstraintViolation</code>), even if some or all of these validations fail during the execution chain.</p>
</div>
<div class="paragraph">
<p>It is helpful when you want to combine validation results of multiple <a href="https://martinfowler.com/bliki/ValueObject.html">Value Object</a>s to produce a new object. (Of course, it is also useful for any objects other than Value Objects.)</p>
</div>
<div class="sect2">
<h3 id="_validating_with_applicative_functor">Validating with Applicative Functor</h3>
<div class="paragraph">
<p><code>am.ik.yavi.fn.Validation&lt;E, T&gt;</code> class is the implementation of Applicative Functor. <code>E</code> is the type of error and <code>T</code> is the type of target object.</p>
</div>
<div class="paragraph">
<p>It can be obtained by <code>am.ik.yavi.core.ApplicativeValidator</code> that can be converted from <code>Validator</code> by <code>applicative()</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Validator&lt;User&gt; validator = ValidatorBuilder.&lt;User&gt; of()
    .constraint(User::getName, "name", c -&gt; c.notNull().lessThanOrEqual(20))
    // ...
    .build();

ApplicativeValidator&lt;User&gt; applicativeValidator = validator.applicative();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>am.ik.yavi.core.Validated&lt;T&gt;</code> is a shortcut of <code>Validation&lt;ConstraintViolation, T&gt;</code> which is specialized for <code>Validator</code> 's usage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Validator&lt;Email&gt; emailValidator = ValidatorBuilder.&lt;Email&gt; of()
    .constraint(Email::value, "email", c -&gt; c.notBlank().email())
    .build();
Validator&lt;PhoneNumber&gt; phoneNumberValidator = ValidatorBuilder.&lt;PhoneNumber&gt; of()
    .constraint(PhoneNumber::value, "phoneNumber", c -&gt; c.notBlank().pattern("[0-9\\-]+"))
    .build();

Validated&lt;Email&gt; emailValidated = emailValidator.applicative().validate(email);
Validated&lt;PhoneNumber&gt; phoneNumberValidated = phoneNumberValidator.applicative().validate(phoneNumber);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The validated target or constraint violations can be retrieved from the <code>Validated</code> instance as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">if (emailValidated.isValid()) {
    Email email = emailValidated.value(); // throws NoSuchElementException if it is invalid
} else {
    ConstraintViolations violations = emailValidated.errors(); // throws NoSuchElementException if it is valid
}
// or
Email email = emailValidated.orElseThrow(violations -&gt; new ConstraintViolationsException(violations));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fold</code> method is convenient if you want to create an instance of the same type regardless of the success or failure of the validation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HttpStatus status = emailValidated.fold(violations -&gt; HttpStatus.BAD_REQUEST, email -&gt; HttpStatus.OK);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_combining_validation_validated_objects">Combining <code>Validation</code> / <code>Validated</code> objects</h3>
<div class="paragraph">
<p><code>Validation</code> / <code>Validated</code> objects can be combined to produce a new object.
In the bellow example, <code>ContactInfo</code> instance is created using <code>Email</code> and <code>PhoneNumber</code> after validating them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Validated&lt;ContactInfo&gt; contactInfoValidated = emailValidated.combine(phoneNumberValidated)
    .apply((em, ph) -&gt; new ContactInfo(em, ph));
// or
Validated&lt;ContactInfo&gt; contactInfoValidated = Validations.combine(emailValidated, phoneNumberValidated)
    .apply((em, ph) -&gt; new ContactInfo(em, ph));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important thing here is that even if the validation of <code>Email</code> or <code>PhoneNumber</code> fails, all validation results are aggregated without shortcuts in the middle.</p>
</div>
<div class="paragraph">
<p>For example, if you put a blank space in <code>Email</code> and <code>a</code> in <code>PhoneNumber</code> and try to create a <code>ContactInfo</code>, the validation will fail, and you will get the following three <code>ContraintViolation</code> s:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* "email" must not be blank
* "email" must be a valid email address
* "phoneNumber" must match [0-9\-]+</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Validation for <code>ContactInfo</code> in the above example can be achieved by using <code>nest</code> method as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Validator&lt;Email&gt; emailValidator = ValidatorBuilder.&lt;Email&gt; of()
    .constraint(Email::value, "value", c -&gt; c.notBlank().email())
    .build();
Validator&lt;PhoneNumber&gt; phoneNumberValidator = ValidatorBuilder.&lt;PhoneNumber&gt; of()
    .constraint(PhoneNumber::value, "value", c -&gt; c.notBlank().pattern("[0-9\\-]+"))
    .build();

Validator&lt;ContactInfo&gt; validator = ValidatorBuilder.&lt;ContactInfo&gt; of()
    .nest(ContactInfo::email, "email", emailValidator)
    .nest(ContactInfo::phoneNumber, "phoneNumber", phoneNumberValidator)
    .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can combine <code>ApplicativeValidator&lt;Email&gt;</code> and <code>ApplicativeValidator&lt;PhoneNumber&gt;</code> as introduced in <a href="#combining-validators">[combining-validators]</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Arguments2Validator&lt;Email, PhoneNumber, ContactInfo&gt; contactInfoValidator = ArgumentsValidators
    .split(emailValidator.applicative(), phoneNumberValidator.applicative())
    .apply(ContactInfo::new);

Validated&lt;ContactInfo&gt; contactInfoValidated = contactInfoValidator.validate(new Email("yavi@example.com"), new PhoneNumber("090-123-4567"));</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-06-15 07:16:43 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/github.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</body>
</html>